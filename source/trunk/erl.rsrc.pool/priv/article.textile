= Resource Pool =

[[File:erlang.png]]

{{CodeSnippet|Code listing 2.2: Create the Agent Information File|<pre>
sample
</pre>}}
<table width="100%" border="0"><tr><td bgcolor="#bbffbb"><p class="note"><b>Note: </b>Control-D to terminate</p></td></tr></table>


== Introduction ==

Reusing resources that have time and memory cost to create can dramatically improve application performance.
[http://sourceforge.net/projects/erlpool Erlang resource pool] project in Sourceforge was inspired by 
Apache Commons Pool Java library. API and main functioning principals was borrowed from there, but internal 
implementation is completely different and is using Erlang OTP design principles and Erlang concurrent model.

== Design ==
Resource pool consists of two containers: 'Active' and 'Idle'. 'Active' container keeps references to
resources that are actively used by some processes. Oppositely 'Idle' container keeps resources that are not
used anywhere and they are in inactive state but ready to use.

      +-Pool-----------{0,0}-+
      |                      |
      | Active--+  Idle----+ |
      | |       |  |       | |
      | |       |  |       | |
      | |       |  |       | |
      | +-------+  +-------+ |
      +----------------------+

We will use a diagram below to explain operations with pool in following text. Symbols in right of first
line <code>-{0,0}-</code> show the load of containers: <code>-{N_active,N_idle}-</code>, where:<br/>
<code>N_active</code> - number of active resorces;<br/>
<code>N_idle</code> - number of idle resources.

== Operations ==

First thing we have to do is create an instance of resource pool.

{.{CodeSnippet|Listing 1: Create resource pool|<pre>
  {ok, Pid} = resource_pool:new(test_pool, resource_factory)
</pre>}}

<code>test_pool</code> is a registered name for the new pool and <code>resource_factory</code> is a name of a module 
that implements resource_factory behaviour. Now we can use <code>test_pool</code>
or <code>Pid</code> as a reference to pool instance. Resource factory module will be responsable for creating, checking and disposing
resource instances and is discussed in details in [[#Resource factory]] below.

The common use of the resource pool is when a few concurrently running processes shares the same pool to borrow resources from it.

=== borrow ===
To retrieve a resource from pool process has to call function <code>borrow</code>.

{.{CodeSnippet|Listing 2: Borrow resource from the pool|<pre>
  Resource = resource_pool:borrow(test_pool)
</pre>}}

If Idle list is empty the pool creates new resource and grants it to caling process.
      +-Pool-----------{1,0}-+          +-Pool-----------{2,0}-+
      |                      |          |                      |
      | Active--+  Idle----+ |          | Active--+  Idle----+ |
      | |       |  |       | |          | |       |  |       | |
      | |       |  |       | |    =>    | | <R.2> |  |       | |
      | | <R.1> |  |       | |          | | <R.1> |  |       | |
      | +-------+  +-------+ |          | +-------+  +-------+ |
      +----------------------+          +----------------------+

If the pool has idle resource within an idle resource just transfers to Active list and
it is granted to caling process.
      +-Pool-----------{1,2}-+          +-Pool-----------{2,1}-+
      |                      |          |                      |
      | Active--+  Idle----+ |          | Active--+  Idle----+ |
      | |       |  |       | |          | |       |  |       | |
      | |       |  | <R.2> | |    =>    | | <R.2> |  |       | |
      | | <R.1> |  | <R.3> | |          | | <R.1> |  | <R.3> | |
      | +-------+  +-------+ |          | +-------+  +-------+ |
      +----------------------+          +----------------------+

=== return ===
Process has to return a resource to the pool after the process completes using a resource.
In other words the resource is moved from Active list to Idle list. Now other concurrent 
processes can borrow freed resource from the pool.
      +-Pool-----------{2,1}-+          +-Pool-----------{1,2}-+
      |                      |          |                      |
      | Active--+  Idle----+ |          | Active--+  Idle----+ |
      | |       |  |       | |          | |       |  |       | |
      | | <R.2> |  |       | |    =>    | |       |  | <R.2> | |
      | | <R.1> |  | <R.3> | |          | | <R.1> |  | <R.3> | |
      | +-------+  +-------+ |          | +-------+  +-------+ |
      +----------------------+          +----------------------+

=== add ===
Sometimes we need just add new resource to pool. Function <code>add</code> creates new resource and
puts it into Idle list. 
      +-Pool-----------{2,1}-+          +-Pool-----------{2,2}-+
      |                      |          |                      |
      | Active--+  Idle----+ |          | Active--+  Idle----+ |
      | |       |  |       | |          | |       |  |       | |
      | | <R.2> |  |       | |    =>    | | <R.2> |  | <R.4> | |
      | | <R.1> |  | <R.3> | |          | | <R.1> |  | <R.3> | |
      | +-------+  +-------+ |          | +-------+  +-------+ |
      +----------------------+          +----------------------+

=== invalidate ===
If resource failed process has to let know about it to the pool. <code>invalidate</code> function marks failed resource
as unusable and pool will be destroy it shortly. 
      +-Pool-----------{2,1}-+          +-Pool-----------{1,1}-+
      |                      |          |                      |
      | Active--+  Idle----+ |          | Active--+  Idle----+ |
      | |       |  |       | |          | |       |  |       | |
      | | <R.2> |  |       | |    =>    | |       |  |       | |
      | | <R.1> |  | <R.3> | |          | | <R.1> |  | <R.3> | |
      | +-------+  +-------+ |          | +-------+  +-------+ |
      +----------------------+          +----------------------+

=== typical use case ===
Suppose that <code>resource</code> module implements some operations under resource.

{.{CodeSnippet|Listing 3: Typical use case of a resource pool|<pre>
  case resource_pool:borrow(test_pool) of
    {error, E} -> io:format("Error while borrow from pool, reason: ~p", [E]);
    Resource ->
      try
        resource:operation(Resource),
        resource_pool:return(test_pool, Resource)
      catch
        _:_ -> resource_pool:invalidate(test_pool, Resource)
      end,
  end,
</pre>}}

If everything is going well we see flow like this: borrow --> use --> return. When something wrong is happened during 
resource use then we have other flow: borrow --> use --> invalidate. 
== Size limits ==

             +-Pool-----------{0,0}-+
             |                      |
             | Active--+  Idle----+ |
             | |       |  |_______|_|__ max_idle
 max_active__|_|_______|  |       | |
             | |       |  |       | |
             | |       |  |_______|_|__ min_idle
             | |       |  |       | |
             | +-------+  +-------+ |
             +----------------------+

=== max_active ===
=== max_idle ===
=== min_idle ===

== Behaviour options ==
=== Borrow with exhausted pool ===
=== Resource checking ===
=== Resource order in idle container ===
=== Timing ===

== Maintenance of pool instance ==
=== new ===
=== clear ===
=== close ===
=== get_num_active, get_num_idle, get_number ===

== Resource factory ==

== Examples ==
=== Connection pool for MySQL driver ===
=== Channel pool for Rabbit MQ connection ===
